<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ Cosmic Runner - ESP32 LDR Game</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
        }

        #gameContainer {
            text-align: center;
            position: relative;
        }

        #gameCanvas {
            border: 3px solid rgba(0, 255, 255, 0.3);
            background: transparent;
            display: block;
            margin: 0 auto;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.2),
                        inset 0 0 40px rgba(0, 0, 0, 0.5);
            border-radius: 10px;
        }

        #score {
            font-size: 28px;
            font-weight: 900;
            margin-top: 20px;
            background: linear-gradient(45deg, #00f5ff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
        }

        #highScore {
            font-size: 18px;
            color: #ff00ff;
            margin-top: 5px;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
        }

        #instructions {
            margin-top: 15px;
            color: #00f5ff;
            font-size: 14px;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.3);
            line-height: 1.6;
        }

        #status {
            margin-top: 10px;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: bold;
            border: 2px solid;
            backdrop-filter: blur(10px);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .ready {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
            color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        .game-over {
            background: rgba(255, 0, 136, 0.2);
            border-color: #ff0088;
            color: #ff0088;
            box-shadow: 0 0 20px rgba(255, 0, 136, 0.3);
        }

        .playing {
            background: rgba(0, 245, 255, 0.2);
            border-color: #00f5ff;
            color: #00f5ff;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.3);
        }

        .glow {
            position: absolute;
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, rgba(0, 245, 255, 0.1), transparent);
            border-radius: 50%;
            pointer-events: none;
            filter: blur(40px);
            animation: float 6s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0); }
            50% { transform: translate(20px, -20px); }
        }
    </style>
</head>
<body>
    <div class="glow" style="top: 10%; left: 20%;"></div>
    <div class="glow" style="top: 60%; right: 10%; animation-delay: 3s;"></div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="900" height="400"></canvas>
        <div id="score">SCORE: 0</div>
        <div id="highScore">HIGH SCORE: 0</div>
        <div id="instructions">
            üöÄ <strong>COSMIC RUNNER</strong> üåå<br>
            Wave hand over LDR sensor to boost through space!<br>
            <small>‚å®Ô∏è SPACE or üñ±Ô∏è CLICK to test</small>
        </div>
        <div id="status" class="ready">‚ö° READY FOR LAUNCH ‚ö°</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const highScoreDisplay = document.getElementById('highScore');
        const statusDisplay = document.getElementById('status');

        // Game variables
        let gameRunning = false;
        let gameOver = false;
        let score = 0;
        let highScore = localStorage.getItem('cosmicHighScore') || 0;
        let frameCount = 0;
        let gameSpeed = 5;

        // Rocket ship properties
        const rocket = {
            x: 100,
            y: 0,
            width: 60,
            height: 35,
            velocityY: 0,
            boosting: false,
            gravity: 0.6,
            boostPower: -13,
            rotation: 0,
            trail: []
        };

        // Ground/platform
        const ground = {
            y: canvas.height - 80,
            height: 80
        };

        rocket.y = ground.y - rocket.height - 50;

        // Obstacles (asteroids and space debris)
        let obstacles = [];
        let obstacleSpawnTimer = 0;
        let obstacleSpawnInterval = 90;

        // Particles and stars
        let stars = [];
        let particles = [];
        let explosionParticles = [];

        // Background layers for parallax
        let bgLayers = [];

        // Initialize
        function init() {
            obstacles = [];
            particles = [];
            explosionParticles = [];
            stars = createStars();
            bgLayers = createBackgroundLayers();
            score = 0;
            frameCount = 0;
            gameSpeed = 5;
            obstacleSpawnTimer = 0;
            rocket.y = ground.y - rocket.height - 50;
            rocket.velocityY = 0;
            rocket.boosting = false;
            rocket.rotation = 0;
            rocket.trail = [];
            gameOver = false;
            updateScore();
        }

        function createStars() {
            const starArray = [];
            for (let i = 0; i < 150; i++) {
                starArray.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2,
                    speed: Math.random() * 2 + 1,
                    opacity: Math.random(),
                    twinkleSpeed: Math.random() * 0.05
                });
            }
            return starArray;
        }

        function createBackgroundLayers() {
            const layers = [];
            for (let i = 0; i < 3; i++) {
                const layer = [];
                for (let j = 0; j < 5; j++) {
                    layer.push({
                        x: j * 300,
                        y: Math.random() * canvas.height * 0.6,
                        type: Math.floor(Math.random() * 3),
                        speed: (i + 1) * 0.5
                    });
                }
                layers.push(layer);
            }
            return layers;
        }

        // Draw functions
        function drawGradientBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0a0e27');
            gradient.addColorStop(0.5, '#16213e');
            gradient.addColorStop(1, '#1a1a2e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawStars() {
            stars.forEach(star => {
                star.opacity += star.twinkleSpeed;
                if (star.opacity > 1 || star.opacity < 0.3) {
                    star.twinkleSpeed *= -1;
                }
                
                ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
                
                if (star.size > 1) {
                    ctx.fillStyle = `rgba(0, 245, 255, ${star.opacity * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        function drawBackgroundLayers() {
            bgLayers.forEach((layer, index) => {
                layer.forEach(obj => {
                    ctx.save();
                    ctx.globalAlpha = 0.3 - index * 0.1;
                    
                    if (obj.type === 0) {
                        // Planet
                        const gradient = ctx.createRadialGradient(obj.x, obj.y, 5, obj.x, obj.y, 25);
                        gradient.addColorStop(0, '#ff00ff');
                        gradient.addColorStop(1, '#8000ff');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(obj.x, obj.y, 25, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (obj.type === 1) {
                        // Nebula
                        const gradient = ctx.createRadialGradient(obj.x, obj.y, 0, obj.x, obj.y, 40);
                        gradient.addColorStop(0, 'rgba(0, 255, 136, 0.3)');
                        gradient.addColorStop(1, 'transparent');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(obj.x - 40, obj.y - 40, 80, 80);
                    }
                    
                    ctx.restore();
                });
            });
        }

        function drawRocket() {
            ctx.save();
            
            // Draw trail
            rocket.trail.forEach((pos, index) => {
                const alpha = index / rocket.trail.length;
                const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, 15);
                gradient.addColorStop(0, `rgba(0, 245, 255, ${alpha * 0.6})`);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 10, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.translate(rocket.x + rocket.width / 2, rocket.y + rocket.height / 2);
            ctx.rotate(rocket.rotation);
            
            // Rocket body (sleek design)
            const bodyGradient = ctx.createLinearGradient(-30, 0, 30, 0);
            bodyGradient.addColorStop(0, '#00f5ff');
            bodyGradient.addColorStop(0.5, '#0099ff');
            bodyGradient.addColorStop(1, '#00f5ff');
            ctx.fillStyle = bodyGradient;
            
            ctx.beginPath();
            ctx.moveTo(25, 0);
            ctx.lineTo(-20, -15);
            ctx.lineTo(-25, 0);
            ctx.lineTo(-20, 15);
            ctx.closePath();
            ctx.fill();
            
            // Cockpit window
            const windowGradient = ctx.createRadialGradient(5, 0, 0, 5, 0, 8);
            windowGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            windowGradient.addColorStop(1, 'rgba(0, 245, 255, 0.5)');
            ctx.fillStyle = windowGradient;
            ctx.beginPath();
            ctx.arc(5, 0, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Wings
            ctx.fillStyle = '#ff00ff';
            ctx.beginPath();
            ctx.moveTo(-10, -15);
            ctx.lineTo(-15, -25);
            ctx.lineTo(-5, -15);
            ctx.closePath();
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(-10, 15);
            ctx.lineTo(-15, 25);
            ctx.lineTo(-5, 15);
            ctx.closePath();
            ctx.fill();
            
            // Engine glow
            if (rocket.boosting || gameRunning) {
                const flameGradient = ctx.createLinearGradient(-25, 0, -40, 0);
                flameGradient.addColorStop(0, 'rgba(255, 136, 0, 0.9)');
                flameGradient.addColorStop(0.5, 'rgba(255, 0, 136, 0.7)');
                flameGradient.addColorStop(1, 'transparent');
                ctx.fillStyle = flameGradient;
                
                const flameSize = rocket.boosting ? 25 : 15;
                ctx.beginPath();
                ctx.moveTo(-25, 0);
                ctx.lineTo(-25 - flameSize, -8);
                ctx.lineTo(-25 - flameSize + 5, 0);
                ctx.lineTo(-25 - flameSize, 8);
                ctx.closePath();
                ctx.fill();
            }
            
            ctx.restore();
            
            // Glow effect
            ctx.save();
            ctx.globalAlpha = 0.3;
            const glowGradient = ctx.createRadialGradient(
                rocket.x + rocket.width/2, rocket.y + rocket.height/2, 0,
                rocket.x + rocket.width/2, rocket.y + rocket.height/2, 40
            );
            glowGradient.addColorStop(0, 'rgba(0, 245, 255, 0.5)');
            glowGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(rocket.x + rocket.width/2, rocket.y + rocket.height/2, 40, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawGround() {
            // Energy platform
            const platformGradient = ctx.createLinearGradient(0, ground.y, 0, canvas.height);
            platformGradient.addColorStop(0, 'rgba(0, 245, 255, 0.3)');
            platformGradient.addColorStop(1, 'rgba(0, 100, 255, 0.1)');
            ctx.fillStyle = platformGradient;
            ctx.fillRect(0, ground.y, canvas.width, ground.height);
            
            // Grid lines
            ctx.strokeStyle = 'rgba(0, 245, 255, 0.3)';
            ctx.lineWidth = 2;
            
            for (let i = 0; i < canvas.width; i += 50) {
                const offset = (frameCount * gameSpeed * 2) % 50;
                ctx.beginPath();
                ctx.moveTo(i - offset, ground.y);
                ctx.lineTo(i - offset, canvas.height);
                ctx.stroke();
            }
            
            // Horizon line with glow
            ctx.strokeStyle = '#00f5ff';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#00f5ff';
            ctx.beginPath();
            ctx.moveTo(0, ground.y);
            ctx.lineTo(canvas.width, ground.y);
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => {
                ctx.save();
                
                if (obstacle.type === 'asteroid') {
                    // Rotating asteroid
                    ctx.translate(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2);
                    ctx.rotate(obstacle.rotation);
                    
                    const asteroidGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, obstacle.width/2);
                    asteroidGradient.addColorStop(0, '#ff6600');
                    asteroidGradient.addColorStop(0.7, '#ff0088');
                    asteroidGradient.addColorStop(1, '#8800ff');
                    ctx.fillStyle = asteroidGradient;
                    
                    ctx.beginPath();
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 / 8) * i;
                        const radius = obstacle.width/2 + Math.random() * 5;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    // Glow
                    ctx.globalAlpha = 0.4;
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                } else {
                    // Energy crystal
                    ctx.translate(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2);
                    
                    const crystalGradient = ctx.createLinearGradient(-obstacle.width/2, 0, obstacle.width/2, 0);
                    crystalGradient.addColorStop(0, 'rgba(255, 0, 255, 0.8)');
                    crystalGradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.8)');
                    crystalGradient.addColorStop(1, 'rgba(255, 0, 255, 0.8)');
                    ctx.fillStyle = crystalGradient;
                    
                    ctx.beginPath();
                    ctx.moveTo(0, -obstacle.height/2);
                    ctx.lineTo(obstacle.width/3, 0);
                    ctx.lineTo(0, obstacle.height/2);
                    ctx.lineTo(-obstacle.width/3, 0);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Inner glow
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.moveTo(0, -obstacle.height/4);
                    ctx.lineTo(obstacle.width/6, 0);
                    ctx.lineTo(0, obstacle.height/4);
                    ctx.lineTo(-obstacle.width/6, 0);
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.restore();
            });
        }

        function drawParticles() {
            particles.forEach((p, index) => {
                ctx.fillStyle = `rgba(${p.color}, ${p.life})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;
                
                if (p.life <= 0) particles.splice(index, 1);
            });
            
            explosionParticles.forEach((p, index) => {
                ctx.fillStyle = `rgba(${p.color}, ${p.life})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.3;
                p.life -= 0.03;
                p.size *= 0.97;
                
                if (p.life <= 0) explosionParticles.splice(index, 1);
            });
        }

        function drawScore() {
            ctx.fillStyle = '#00f5ff';
            ctx.font = 'bold 24px Orbitron';
            ctx.textAlign = 'right';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00f5ff';
            ctx.fillText('SCORE: ' + Math.floor(score), canvas.width - 20, 35);
            
            ctx.fillStyle = '#ff00ff';
            ctx.shadowColor = '#ff00ff';
            ctx.font = '16px Orbitron';
            ctx.fillText('BEST: ' + highScore, canvas.width - 20, 60);
            ctx.shadowBlur = 0;
            ctx.textAlign = 'left';
            
            if (gameOver) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.font = 'bold 48px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#ff0088';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff0088';
                ctx.fillText('MISSION FAILED', canvas.width / 2, canvas.height / 2 - 40);
                
                ctx.font = 'bold 24px Orbitron';
                ctx.fillStyle = '#00f5ff';
                ctx.shadowColor = '#00f5ff';
                ctx.fillText('Wave hand to retry', canvas.width / 2, canvas.height / 2 + 20);
                
                ctx.font = '18px Orbitron';
                ctx.fillStyle = '#00ff88';
                ctx.shadowColor = '#00ff88';
                ctx.fillText('Final Score: ' + Math.floor(score), canvas.width / 2, canvas.height / 2 + 60);
                ctx.restore();
            }
        }

        // Update functions
        function updateRocket() {
            if (rocket.boosting) {
                rocket.velocityY += rocket.gravity;
                rocket.y += rocket.velocityY;
                rocket.rotation = Math.min(rocket.velocityY * 0.02, 0.3);

                // Add trail
                rocket.trail.push({x: rocket.x, y: rocket.y + rocket.height/2});
                if (rocket.trail.length > 15) rocket.trail.shift();

                if (rocket.y >= ground.y - rocket.height - 50) {
                    rocket.y = ground.y - rocket.height - 50;
                    rocket.velocityY = 0;
                    rocket.boosting = false;
                    rocket.rotation = 0;
                }
                
                // Add boost particles
                if (frameCount % 2 === 0) {
                    particles.push({
                        x: rocket.x,
                        y: rocket.y + rocket.height/2,
                        vx: -Math.random() * 3 - 2,
                        vy: (Math.random() - 0.5) * 2,
                        size: Math.random() * 3 + 2,
                        life: 1,
                        color: '0, 245, 255'
                    });
                }
            } else {
                rocket.trail = [];
            }
        }

        function updateObstacles() {
            obstacles.forEach(obstacle => {
                obstacle.x -= gameSpeed;
                if (obstacle.type === 'asteroid') {
                    obstacle.rotation += 0.05;
                }
            });

            obstacles = obstacles.filter(obstacle => obstacle.x + obstacle.width > 0);

            obstacleSpawnTimer++;
            if (obstacleSpawnTimer > obstacleSpawnInterval) {
                const type = Math.random() > 0.5 ? 'asteroid' : 'crystal';
                const size = 30 + Math.random() * 30;
                obstacles.push({
                    x: canvas.width,
                    y: ground.y - size - 50,
                    width: size,
                    height: size,
                    type: type,
                    rotation: 0
                });
                obstacleSpawnTimer = 0;
                obstacleSpawnInterval = 70 + Math.random() * 60;
            }
        }

        function updateStars() {
            stars.forEach(star => {
                star.x -= star.speed;
                if (star.x < -5) {
                    star.x = canvas.width + 5;
                    star.y = Math.random() * canvas.height;
                }
            });
        }

        function updateBackgroundLayers() {
            bgLayers.forEach(layer => {
                layer.forEach(obj => {
                    obj.x -= obj.speed;
                    if (obj.x < -50) {
                        obj.x = canvas.width + 50;
                        obj.y = Math.random() * canvas.height * 0.6;
                    }
                });
            });
        }

        function updateScore() {
            scoreDisplay.textContent = 'SCORE: ' + Math.floor(score);
            highScoreDisplay.textContent = 'HIGH SCORE: ' + highScore;
        }

        function checkCollision() {
            const rocketCenterX = rocket.x + rocket.width/2;
            const rocketCenterY = rocket.y + rocket.height/2;
            const rocketRadius = 20;

            for (let obstacle of obstacles) {
                const obstacleCenterX = obstacle.x + obstacle.width/2;
                const obstacleCenterY = obstacle.y + obstacle.height/2;
                const obstacleRadius = obstacle.width/2;

                const distance = Math.sqrt(
                    Math.pow(rocketCenterX - obstacleCenterX, 2) +
                    Math.pow(rocketCenterY - obstacleCenterY, 2)
                );

                if (distance < rocketRadius + obstacleRadius - 5) {
                    createExplosion(rocketCenterX, rocketCenterY);
                    return true;
                }
            }
            return false;
        }

        function createExplosion(x, y) {
            for (let i = 0; i < 30; i++) {
                const angle = (Math.PI * 2 / 30) * i;
                const speed = Math.random() * 5 + 2;
                explosionParticles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: Math.random() * 4 + 2,
                    life: 1,
                    color: Math.random() > 0.5 ? '255, 0, 136' : '0, 245, 255'
                });
            }
        }

        function boost() {
            if (!rocket.boosting && !gameOver) {
                if (!gameRunning) {
                    gameRunning = true;
                    statusDisplay.className = 'playing';
                    statusDisplay.textContent = 'üöÄ MISSION IN PROGRESS üöÄ';
                }
                
                rocket.velocityY = rocket.boostPower;
                rocket.boosting = true;
            } else if (gameOver) {
                init();
                gameRunning = true;
                gameOver = false;
                statusDisplay.className = 'playing';
                statusDisplay.textContent = 'üöÄ MISSION IN PROGRESS üöÄ';
            }
        }

        function gameLoop() {
            drawGradientBackground();
            drawBackgroundLayers();
            drawStars();
            drawGround();
            drawObstacles();
            drawParticles();
            drawRocket();
            drawScore();

            if (gameRunning && !gameOver) {
                updateRocket();
                updateObstacles();
                updateStars();
                updateBackgroundLayers();
                
                score += 0.1;
                frameCount++;
                
                if (frameCount % 600 === 0) {
                    gameSpeed += 0.5;
                }

                if (checkCollision()) {
                    gameOver = true;
                    gameRunning = false;
                    statusDisplay.className = 'game-over';
                    statusDisplay.textContent = 'üí• MISSION FAILED üí•';
                    
                    if (score > highScore) {
                        highScore = Math.floor(score);
                        localStorage.setItem('cosmicHighScore', highScore);
                    }
                }

                updateScore();
            }

            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                boost();
            }
        });

        canvas.addEventListener('click', () => {
            boost();
        });

        init();
        updateScore();
        gameLoop();

        console.log('üöÄ Cosmic Runner initialized!');
        console.log('üì° Waiting for ESP32 BLE connection...');
        console.log('‚ö° Device: ESP32 Dino');
    </script>
</body>
</html>
